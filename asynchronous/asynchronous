#				并发(信号 - 初步异步 / 线程 - 强烈异步)  

同步
	

异步
	异步事件的处理：查询 / 通知
		异步事件发生频率低	使用通知法
		异步事件发生频率高	使用查询法

	在软件层面没有真正的通知法	其实没有严格意义上的通知法

------信号-------

1-	信号是什么 - 信号的概念
		信号是软件层面的中断。	信号的响应依赖于中断
		$kill -l ;查看信号内容

2-	signal();
		#include <signal.h>

		typedef void (*sighandler_t)(int);
		sighandler_t signal(int signum, sighandler_t handler);

		void (*signal(int signum, void (*handler)(int)))(int);
		信号会打断阻塞的系统调用.

3-	信号的不可靠
		信号的行为不可靠:执行不是我们控制的，现场也不是我们布置的

4-	重入 / 可重入函数
		为了解决信号的不可靠性
		第一次调用没有结束，就发生第二次调用的情况下也是可以的
		所有的系统调用都是可重入的，一部分库函数也是可重入的,如：memcpy();带_r后缀名版本的库函数都是可重入的

5-	信号的响应过程
	信号从收到到响应由一个不可避免的延迟
	思考：信号是如何忽略掉的？
		  标准信号为什么要丢失？
		  	pending置1就置1，无法记录置了几次，只能记录最后一次的记录

		  标准信号的响应没有严格的顺序 ！！
	信号实际上是在由kernel回到user的路上响应的

	不能控制信号什么时候到来，但是可以控制信号在什么时候被响应以及是否被响应

6-	信号的常用函数
		#include <sys/types.h>
		#include <signal.h>
	
		int kill(pid_t pid, int sig);	//给一个进程发送信号
		int raise(int sig);	//给当前进程发送一个信号
		alarm();
		pause();
		abort();
		system();

		sleep();的问题

7-	信号集

8-	信号屏蔽字 / pending集 的处理

9-	扩展
		sigsuspend();
		sigaction();	//替换signal()函数
		setitimer();	// 替换alarm()函数

10-	实时信号相关内容

-----多线程------


